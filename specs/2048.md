Events:
- mouse: swipe left/right/up/down
  - user swipes in a direction -> SWIPED (direction)
- keyboard:
  - user presses a key -> KEY_PRESSED (key)
- browser:
  - user navigates to page -> NAVIGATED
- application:
  - user starts new game -> STARTED_NEW_GAME

Effects:
- .-> display: render
- <-> random generator: generator (uniform distribution, 0, 1, seed)
- .-> emit event: emit_event (event type, event payload)

(Note: <-|-> for effects that return a value asynchronously)


Reactions:
NAVIGATED -> 
  game_status <- NOT_STARTED
  best_score <- 0
  current_score <- 0
  overlay <- None
  board_state <- empty_board (4,4)
  -> !render (app, app state)

STARTED_NEW_GAME -> 
  game_status <- GAME_IN_PROGRESS
  current_score <- 0
  new_cell_1 <- generate_random_new_cell(generator)
  new_cell_2 <- generate_random_new_cell(generator)
  board_state <- add_cells(board_state, [new_cell_1, new_cell_2])
  -> render (app, app state, changed: board)

| game_status = GAME_IN_PROGRESS |:
KEY_PRESSED (key) -> 
  direction <- [LEFT, RIGHT, UP, DOWN] <= [left arrow key, right arrow key, up arrow key, down arrow key]
  -> emit event SWIPED (direction)

SWIPED (direction) ->
  points <- eval_swipe(board_state, direction)
  points > 0 => , UP_ARROW, DOWN_ARROW]
  points <- eval_swipe(board_state, direction)
  points > 0 => 
    current_score <- current_score + points
    best_score <- max(best_score, current_score)
    new_cell <- generate_random_new_cell_in_free_space(generator, board_state)
    board_state <- add_cells(play_swipe(board_state, direction), [new_cell])
    overlay, game_status <- did_user_win(board_state) 
      ? USER_WON, GAME_OVER 
      : did_user_lose(board_state) 
        ? USER_LOST, GAME_OVER 
        : None, GAME_IN_PROGRESS
    -> render(app, app state)

---
render (target element, app state, changed):
  - renders HTML content on a target element
  - the HTML content to display is computed from the app state passed as parameter
  - there are two rendering modes, which are similar to immediate and retained mode.
  - if no changed parameter is passed as arguments, the content is rendered in whichever way fits
  - if a changed parameter is passed as argument, only the changes are rendered (retained mode)
    - content is a function of view model parameters
    - changed indicates which of those view model parameters have been updated
    - the render function should appropriately render just the part of the content that is affected by the updated view model parameters

- page:
  - contains a top area that displays some messages and the game scores, together with a button to start a new game
  - contains a board area that displays the board state as the game starts or progresses
  - contains a bottom area with some basic instructions
  - Layout: the top area and board area are aligned so the board's right border is the same as the scores section's right border
  - Illustrative example:

------example start
      2048                              +-----------+
Join the tiles, get to 2048!            |   Score   |
How to play                             |     0     |
                                        +-----------+
                                        |    Best   |
                                        |     0     |
                                        +-----------+
                                        | New game  |
                                        +-----------+

+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+


HOW TO PLAY: Use your arrow keys to move the
tiles. Tiles with the same number merge into one 
when they touch. Add them up to reach 2048!

Start playing
------example end

- board:
  - displays a 4x4 squared tables of which each cell will possibly hold a number as the game starts or progresses
  - the cells array of value is passed as parameter
  - Example 1 (board after user clicked on new game button):

------example start 
+------------+------------+------------+------------+
|      2     |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |     4      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

  - Example 2 (possible board as the game goes on):

------example start 
+------------+------------+------------+------------+
|            |      2     |            |     2      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |     4      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

  - Example 3 (empty board):
  ------example start
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

- overlay: 
  - transparent layer that displays Game over in large characters
  - the overlay covers only the board area
  - the overlay covers the entire board area
  - the overlay can be displayed or hidden depending on parameter passed to render function

(NOTE: https://gemini.google.com/app/8a9ba7f9f26f5335 the render could not be tested in console)

generator:
  - should generate a random number between 0 and 1 according to a uniform distribution law
  - should take a seed parameter that ensures repeatability of the generated numbers
  - needs not be cryptographically secure. Pseudo-randomness is enough.
  - needs to be reasonably fast at generating numbers. In the worse case, a number should be generated below 1ms.

(NOTE: https://gemini.google.com/app/7c9289ff7007fab8 gets us a generator with a number seed with cases we hadn't though of!)

generate_random_new_cell(generator):
- use the random generator to pick a number that is either 2 (with 90% probability) or 4 (with 10% probability)
- use the random generator to pick a number between 0 and 100 and map that to a cell position
  - 0 will correspond to the top left corner
  - 1 corresponds to the next cell on the right
  - 5 corresponds to the first cell in the second row from the top
  - 16 will correspond to the same cell position as 0
  - numbers over 16 will correspond the same cell position than the number minus 16
  - in other words, the cell location is determined by the generated number modulo 16

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

generate_random_new_cell_in_free_space(generator, board_state):
- use the random generator to pick a number that is either 2 (with 90% probability) or 4 (with 10% probability)
- use the random generator to pick a number between 0 and 100 and map that to a cell position
  - number_free_cells <- the number of free cells on the board
  - n <- generated number modulo number_free_cells
  - pick the cell location that is the nth free cell in the board 

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

empty_board (4,4):
- returns an empty board that is 4 rows and four columns

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

add_cells(board_state, [new_cell_1, new_cell_2, ...]):
- adds the cells passed as parameter to the board and return the updated board
- cells are characterized by their value and their location

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

eval_swipe(board_state, direction):
- direction can be one of [LEFT, RIGHT, UP, DOWN]
- Tiles slide as far as possible in the chosen direction until they are stopped by either another tile or the edge of the board. If two tiles of the same number collide while moving, they will merge into a tile with the total value of the two tiles that collided. The resulting tile cannot merge with another tile again in the same move.
- If a move causes three consecutive tiles of the same value to slide together, only the two tiles farthest along the direction of motion will combine. If all four spaces in a row or column are filled with tiles of the same value, a move parallel to that row/column will combine the first two and last two.
- The points to return are the value of the new tiles when they combined

(cf. https://gemini.google.com/app/7c9289ff7007fab8 it actually wrote a function that plays and compute the points at the same time. That is indeed the best approach but I don't want to change my specs :-) the idea is to keep the specs so that we have no intermediate result and every left side variable is only assigned once per triggering event)

did_user_win(board_state):
- true if there is a tile that is 2048

(cf. https://gemini.google.com/app/7c9289ff7007fab8 good but there isn't a loosing board, just a non-winning board)

did_user_lose(board_state):
- true if and only if there are no directions in which the player can swipe that results in the board changing state


emit_event (event type, event payload)
- emits a DOM event with the corresponding type and payload
- 
(cf. https://gemini.google.com/app/7c9289ff7007fab8 good but there isn't a loosing board, just a non-winning board)
