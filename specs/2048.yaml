Events:
- mouse: 
  - user clicks on the left button on the mouse -> MOUSE_DOWN
  - user releases the left button on the mouse -> MOUSE_UP
  - user moves the mouse -> MOUSE_MOVE
- keyboard:
  - user presses a key -> KEY_PRESSED (key)
- swipe:
  - user swipes the mouse in a direction (e.g., left/right/up/down)-> SWIPED (direction)

- browser:
  - user navigates to page -> NAVIGATED
- application:
  - user starts new game -> STARTED_NEW_GAME

Effects:
- .-> display: render
- <-> random generator: generator (uniform distribution, 0, 1, seed)
- .-> emit event: emit_event (event type, event payload)

(Note: <-|-> for effects that return a value asynchronously)

Equations:
  app state = {game_status, best_score, current_score, overlay, board_state}

Reactions:
NAVIGATED -> 
  game_status <- NOT_STARTED
  best_score <- 0
  current_score <- 0
  overlay <- None
  board_state <- empty_board (4,4)
  -> !render (#app, app state)

STARTED_NEW_GAME -> 
  game_status <- GAME_IN_PROGRESS
  current_score <- 0
  new_cell_1 <- generate_random_new_cell(generator)
  new_cell_2 <- generate_random_new_cell(generator)
  board_state <- add_cells(board_state, [new_cell_1, new_cell_2])
  -> render (#app, app state)

| game_status = GAME_IN_PROGRESS |:
KEY_PRESSED (key) -> 
  direction <- [LEFT, RIGHT, UP, DOWN] <= [left arrow key, right arrow key, up arrow key, down arrow key]
  -> emit event SWIPED (direction)

MOUSE_DOWN (x1, y1) ->
  true <- is_down
  MOUSE_MOVE (x2, y2) ->
    is_down =>
      direction <- compute_direction(x1, y1, x2, y2)
  MOUSE_UP -> 
    false <- is_down
    direction =>
      -> emit event SWIPED (direction)

SWIPED (direction) ->
  points <- eval_swipe(board_state, direction)
  points > 0 => 
    current_score <- current_score + points
    best_score <- max(best_score, current_score)
    new_cell <- generate_random_new_cell_in_free_space(generator, board_state)
    board_state <- add_cells(play_swipe(board_state, direction), [new_cell])
    overlay, game_status <- did_user_win(board_state) 
      ? USER_WON, GAME_OVER 
      : did_user_lose(board_state) 
        ? USER_LOST, GAME_OVER 
        : None, GAME_IN_PROGRESS
    -> render(#app, app state)

---
render (target element, app state, changed):
(first iteration):
  - renders HTML content on a target element
  - the HTML content to display is computed from the app state passed as parameter
  - there are two rendering modes, which are similar to immediate and retained mode.
  - if no changed parameter is passed as arguments, the content is rendered in whichever way fits
    - could choose to keep the previous app state passed and compute the changes between the previous and current app state and rendering only the affected pieces of content accordingly
  - if a changed parameter is passed as argument, only the changes are rendered (retained mode)
    - content is a function of view model parameters
    - changed indicates which of those view model parameters have been updated
    - the render function should appropriately render just the part of the content that is affected by the updated view model parameters
  - app state: game_status, best_score, current_score, overlay, board_state
  - page to render
    - contains a top area that displays some messages and the game scores, together with a button to start a new game
    - contains a board area that displays the board state as the game starts or progresses
    - contains a bottom area with some basic instructions
    - Layout: the top area and board area are aligned so the board's right border is the same as the scores section's right border
    - Illustrative example: (tjhis is ASCII but replace with three images of lo-fi model_

------example start
      2048                              +-----------+
Join the tiles, get to 2048!            |   Score   |
How to play                             |     0     |
                                        +-----------+
                                        |    Best   |
                                        |     0     |
                                        +-----------+
                                        | New game  |
                                        +-----------+

+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+


HOW TO PLAY: Use your arrow keys to move the
tiles. Tiles with the same number merge into one 
when they touch. Add them up to reach 2048!

Start playing
------example end

- zoom on the page's board:
  - 4x4 squared table of which each cell will possibly hold a number as the game starts or progresses
  - Example 1 (board after user clicked on new game button):

------example start 
+------------+------------+------------+------------+
|      2     |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |     4      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

  - Example 2 (possible board as the game goes on):

------example start 
+------------+------------+------------+------------+
|            |      2     |            |     2      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |     4      |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

  - Example 3 (empty board):
  ------example start
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
|            |            |            |            |
+------------+------------+------------+------------+
------example end

- overlay: 
  - transparent layer that displays Game over in large characters
  - the overlay covers only the board area
  - the overlay covers the entire board area
  - the overlay can be displayed or hidden depending on parameter passed to render function

(NOTE: https://gemini.google.com/app/8a9ba7f9f26f5335 the render could not be tested in console
- see second attempts after updating the render specs - we are almost there but not quite

![UI generated by Gemini from ASCII art](../AI/UI%20gemini%20generated%20second%20attemps.png))

(2nd iteration):
- passing a hifi picture and asking for html in return
- did not work, see actual 2,3.4. etc.
- https://gemini.google.com/app/7c9289ff7007fab8

(3rd iteration):
- step by step (see #transcript.md)
- that worked better though I did not test the overlay
- https://gemini.google.com/app/2affdd07c04f804b



generator:
  - should generate a random number between 0 and 1 according to a uniform distribution law
  - should take a seed parameter that ensures repeatability of the generated numbers
  - needs not be cryptographically secure. Pseudo-randomness is enough.
  - needs to be reasonably fast at generating numbers. In the worse case, a number should be generated below 1ms.

(NOTE: https://gemini.google.com/app/7c9289ff7007fab8 gets us a generator with a number seed with cases we hadn't though of!)

generate_random_new_cell(generator):
- use the random generator to pick a number that is either 2 (with 90% probability) or 4 (with 10% probability)
- use the random generator to pick a number between 0 and 100 and map that to a cell position
  - 0 will correspond to the top left corner
  - 1 corresponds to the next cell on the right
  - 5 corresponds to the first cell in the second row from the top
  - 16 will correspond to the same cell position as 0
  - numbers over 16 will correspond the same cell position than the number minus 16
  - in other words, the cell location is determined by the generated number modulo 16

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

generate_random_new_cell_in_free_space(generator, board_state):
- use the random generator to pick a number that is either 2 (with 90% probability) or 4 (with 10% probability)
- use the random generator to pick a number between 0 and 100 and map that to a cell position
  - number_free_cells <- the number of free cells on the board
  - n <- generated number modulo number_free_cells
  - pick the cell location that is the nth free cell in the board 

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

empty_board (4,4):
- returns an empty board that is 4 rows and four columns

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

add_cells(board_state, [new_cell_1, new_cell_2, ...]):
- adds the cells passed as parameter to the board and return the updated board
- cells are characterized by their value and their location

(cf. https://gemini.google.com/app/7c9289ff7007fab8)

eval_swipe(board_state, direction):
- direction can be one of [LEFT, RIGHT, UP, DOWN]
- Tiles slide as far as possible in the chosen direction until they are stopped by either another tile or the edge of the board. If two tiles of the same number collide while moving, they will merge into a tile with the total value of the two tiles that collided. The resulting tile cannot merge with another tile again in the same move.
- If a move causes three consecutive tiles of the same value to slide together, only the two tiles farthest along the direction of motion will combine. If all four spaces in a row or column are filled with tiles of the same value, a move parallel to that row/column will combine the first two and last two.
- The points to return are the value of the new tiles when they combined

(cf. https://gemini.google.com/app/7c9289ff7007fab8 it actually wrote a function that plays and compute the points at the same time. That is indeed the best approach but I don't want to change my specs :-) the idea is to keep the specs so that we have no intermediate result and every left side variable is only assigned once per triggering event)

did_user_win(board_state):
- true if there is a tile that is 2048

(cf. https://gemini.google.com/app/7c9289ff7007fab8 good but there isn't a loosing board, just a non-winning board)

did_user_lose(board_state):
- true if and only if there are no directions in which the player can swipe that results in the board changing state

compute_direction(x1, y1, x2, y2):
-TODO!

emit_event (event type, event payload)
- emits a DOM event with the corresponding type and payload
- 
(cf. https://gemini.google.com/app/7c9289ff7007fab8 good but there isn't a loosing board, just a non-winning board)

Predicates:
- is_empty(r, c) <- (board_state <- app_state)
- cell(r,c) <- (board_state <- app_state)
- is_not_started <- (game_status <- app_state)
- is_playing <- (game_status <- app_state)
- is_game_over <- (game_status <- app_state)
- is_game_won <- (game_status <- app_state)
- is_game_lost <- (game_status <- app_state)
- board_is_compacted <- (board_state <- app_state, direction <- SWIPED (direction))
- num_non_empty <- (board_state <- app_state, direction <- SWIPED (direction))
- num_non_empty_decreased_or_same_from_prev <- (board_state <- app_state)', (board_state <- app_state)
- board_changed_from_prev <- (board_state <- app_state)', (board_state <- app_state)
- board_unchanged_from_prev <- (board_state <- app_state)', (board_state <- app_state)
- score_unchanged_from_prev <- (current_score <- app_state)', (current_score <- app_state)
- best_score_unchanged_from_prev <- (best_score <- app_state)', (best_score <- app_state)
- score_increased_from_prev <- (current_score <- app_state)', (current_score <- app_state)
- score_not_decreased_from_prev <- (current_score <- app_state)', (current_score <- app_state)
- has_2048_cell <- (board_state <- app_state)
- can_move <- (board_state <- app_state)
- new_game_transition <- (_ <- STARTED_NEW_GAME)
- sum_of_cells_diff_is_2_or_4 <- (board_state <- app_state)', (board_state <- app_state)

Properties:
- only_powers_of_2 <- cells on the board are either empty or powers of 2
  - AG (FORALL r, c: (is_empty(r, c) OR (cell(r, c) > 0 AND is_power_of_2(cell(r, c)))))
- empty_board_before_game_start <- If the game has not started, there are no non-empty cells on the board
  - AG (is_not_started => (FORALL r, c: is_empty(r, c)))
- game_in_progress_has_min_non_empty_cells <- If the game is being played, there are at least two non-empty cells on the board
  - AG (is_playing => (num_non_empty >= 2))
- player_move_compacts_board <- If the game is being played, and the user made a move in a given direction, there are no empty cells in between non-empty cells in the given direction
  - AG (is_playing => FORALL dir: AX (board_is_compacted))
Note: AX quantifies over all possible next states. If the transition system allows non-move transitions from a playing state, this formula would be too strong. Assuming the only transitions from is_playing states are moves in one of the four directions.
- score_increase_means_changed_board <- If the game is being played, and the user made a move in a given direction, and the score increased, then the board moved and the number of non-empty cells is equal or lower than before the move
  - AG (is_playing IMPLIES FORALL dir: AX (score_increased_from_prev IMPLIES (board_changed_from_prev AND num_non_empty_decreased_or_same_from_prev)))
- unchanged_board_means_unchanged_score <- If the game is being played, and the user made a move in a given direction, and the board after the move is the same as before the move, then the scores remains the same
  - AG (is_playing IMPLIES FORALL dir: AX (NOT board_changed_from_prev IMPLIES score_unchanged_from_prev))
- board_sum_increases_only_with_new_cell <- If the game is being played, and the user made a move in a given direction, and the board changed, then the difference in the sum of the cells is 2 or 4 (with 90/10% probability)
  - AG (is_playing IMPLIES FORALL dir: AX (board_changed_from_prev IMPLIES sum_of_cells_diff_is_2_or_4))
  - can't express probaility with formula so left to AI
- score_only_increases <- the current score never decreases
  - AG (AX score_not_decreased_from_prev)
  - CTL equiv: AG (score <= AX score)
- best_score_only_increases <- best score never decreases
  - AG (AX best_score_not_decreased_from_prev)
- best_score_above_score <- best score is always superior or equal to current score
  - AG (best_score >= score)
- game_lost_when_no_more_moves <- if the game is being played, and the user made a move in a given direction, and the board changed, and no further move will change the board, and there is no cell that is 2048, then the game is over (lost)
  - AG ( (is_playing AND board_changed_from_prev AND NOT can_move AND NOT has_2048_cell) IMPLIES (game_over AND game_lost) )
  - or CTL AG ( is_playing IMPLIES FORALL dir: AX ( (board_changed_from_prev AND NOT can_move AND NOT has_2048_cell) IMPLIES (game_over AND game_lost) ) )
- game_won_when_2048 <- if the game is being played, and the user made a move in a given direction, and the board changed, and there is a cell that is 2048, then the game is over (won)
  - AG ( is_playing IMPLIES FORALL dir: AX ( (board_changed_from_prev AND has_2048_cell) IMPLIES (game_over AND game_won) ) )
- game_over_means_no_more_moves <- if a game is over, and the user made a move in a given direction, scores and board do not change
  - AG (game_over IMPLIES AX (board_unchanged_from_prev AND score_unchanged_from_prev AND best_score_unchanged_from_prev))
- game_restart_means_score_and_board_reset <- if a game is over, and the user starts a new game, the score is reset to 0, and the board is reset to two cells, and the best score does not change.
  - AG (game_over IMPLIES EX (new_game_transition AND score=0 AND num_non_empty=2 AND best_score_unchanged_from_prev))

Examples:
- seed + navigate + loosing game sequence + new game
- seed + navigate + winning game sequence + new game
- seed + navigate + new game X 100 (to check frequencies between expected values)

TODO: separate DOM events from game events. Don't write specs for DOM events. No I should even if there are obvious. This showcases library of reusable components (here events)